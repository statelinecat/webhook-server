# D:/Stateline/Documents/GitHub/webhook-server\app.py
import asyncio
import time
import sqlite3
import os
from contextlib import asynccontextmanager
from typing import List, Dict, Any, Optional
from pydantic import BaseModel
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse, HTMLResponse
import httpx

# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---
DB_PATH = os.getenv("DB_PATH", "signals.db")
PORT = int(os.getenv("PORT", 8001))


# --- –ú–æ–¥–µ–ª–∏ –¥–ª—è —Å–∏–≥–Ω–∞–ª–æ–≤ (–û–ë–ù–û–í–õ–ï–ù–ù–´–ï) ---
class CloseDecrease(BaseModel):
    type: str
    amount: str


class CloseOrder(BaseModel):
    action: str
    decrease: CloseDecrease
    checkProfit: bool
    price: str = ""


class OpenOrder(BaseModel):
    amountType: str
    amount: str
    enabled: bool


class DCAOrder(BaseModel):
    amountType: str
    amount: str
    checkProfit: bool


class SLConfig(BaseModel):
    price: str = ""
    update: bool


class TradingSignal(BaseModel):
    name: str
    secret: str
    side: str
    symbol: str
    close: CloseOrder
    open: OpenOrder
    dca: DCAOrder
    sl: SLConfig
    tp: Optional[Dict[str, Any]] = None


# --- –ü–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ ---
INSTRUMENTS = [
    "1MBABYDOGEUSDT", "1MBABYDOGEUSDTS",
    "1000CATUSDT", "1000CATUSDTS",
    "1000CHEEMSUSDT", "1000CHEEMSUSDTS",
    "1000PEPEUSDT", "1000PEPEUSDTS",
    "1000RATSUSDT", "1000RATSUSDTS",
    "1000SATSUSDT", "1000SATSUSDTS",
    "1000WHYUSDT", "1000WHYUSDTS",
    "B3USDT", "B3USDTS",
    "BANANAS31USDT", "BANANAS31USDTS",
    "BEAMXUSDT", "BEAMXUSDTS",
    "BOMEUSDT", "BOMEUSDTS",
    "BROCCOLIF3BUSDT", "BROCCOLIF3BUSDTS",
    "CELRUSDT", "CELRUSDTS",
    "CKBUSDT", "CKBUSDTS",
    "COSUSDT", "COSUSDTS",
    "DEGENUSDT", "DEGENUSDTS",
    "DENTUSDT", "DENTUSDTS",
    "PTBUSDT", "PTBUSDTS",
    "DOGSUSDT", "DOGSUSDTS",
    "DOODUSDT", "DOODUSDTS",
    "TOSHIUSDT", "TOSHIUSDTS",
    "FUNUSDT", "FUNUSDTS",
    "FUSDT", "FUSDTS",
    "HIPPOUSDT", "HIPPOUSDTS",
    "HMSTRUSDT", "HMSTRUSDTS",
    "HOTUSDT", "HOTUSDTS",
    "IOSTUSDT", "IOSTUSDTS",
    "LEVERUSDT", "LEVERUSDTS",
    "MEMEUSDT", "MEMEUSDTS",
    "MEWUSDT", "MEWUSDTS",
    "NEIROUSDT", "NEIROUSDTS",
    "TOWNSUSDT", "TOWNSUSDT",
    "NOTUSDT", "NOTUSDTS",
    "ONEUSDT", "ONEUSDTS",
    "PUMPUSDT", "PUMPUSDTS",
    "REZUSDT", "REZUSDTS",
    "RSRUSDT", "RSRUSDTS",
    "SPELLUSDT", "SPELLUSDTS",
    "AKEUSDT", "AKEUSDTS",
    "TAGUSDT", "TAGUSDTS",
    "TLMUSDT", "TLMUSDTS",
    "TURBOUSDT", "TURBOUSDTS",
    "VTHOUSDT", "VTHOUSDTS",
    "XVGUSDT", "XVGUSDTS"
]

# --- –í–µ–±—Ö—É–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ ---
FINANDY_WEBHOOKS = {
    "1MBABYDOGEUSDT": "https://hook.finandy.com/TuaL5bAQjTO2kP4trlUK",
    "1MBABYDOGEUSDTS": "https://hook.finandy.com/09V1WmbUktZCq_8trlUK",
    "1000CATUSDT": "https://hook.finandy.com/iFh_Ic-r0LeOFkz5rlUK",
    "1000CATUSDTS": "https://hook.finandy.com/dPpzETmR50zRbU35rlUK",
    "1000CHEEMSUSDT": "https://hook.finandy.com/oGKYnFSG8EcfFUUXrlUK",
    "1000CHEEMSUSDTS": "https://hook.finandy.com/qoOE5ObxuJ9fVFoXrlUK",
    "1000PEPEUSDT": "https://hook.finandy.com/0O0Famu12xI3IT7ZrlUK",
    "1000PEPEUSDTS": "https://hook.finandy.com/jmpa1C-AJJB2vD_ZrlUK",
    "1000RATSUSDT": "https://hook.finandy.com/l8JsSEjNzZd0CTzZrlUK",
    "1000RATSUSDTS": "https://hook.finandy.com/QcFtY7IJXTyUuD3ZrlUK",
    "1000SATSUSDT": "https://hook.finandy.com/dMOLd-EEPHPv84ICrlUK",
    "1000SATSUSDTS": "https://hook.finandy.com/y-ihQVJF3B_TYoMCrlUK",
    "1000WHYUSDT": "https://hook.finandy.com/vD6Y-C5FcYVTF5clrlUK",
    "1000WHYUSDTS": "https://hook.finandy.com/HmIQ65EkmnIe0ZQlrlUK",
    "B3USDT": "https://hook.finandy.com/3BD-SHeKq6e-90P5rlUK",
    "B3USDTS": "https://hook.finandy.com/mPjmmUyexOLbrkD5rlUK",
    "BANANAS31USDT": "https://hook.finandy.com/2-mBZ4Wlq8LXvkjyrlUK",
    "BANANAS31USDTS": "https://hook.finandy.com/XgZw33-Ev83LI0nyrlUK",
    "BEAMXUSDT": "https://hook.finandy.com/8WdHzLmWBXeiMKQ1rlUK",
    "BEAMXUSDTS": "https://hook.finandy.com/2GJI0BxNg1tMpqU1rlUK",
    "BOMEUSDT": "https://hook.finandy.com/3Z-yX4GNQeM4qPACrlUK",
    "BOMEUSDTS": "https://hook.finandy.com/_QAms23yOJcA7fECrlUK",
    "BROCCOLIF3BUSDT": "https://hook.finandy.com/w-SfCLt30P5Z9IL4rlUK",
    "BROCCOLIF3BUSDTS": "https://hook.finandy.com/8_YNXd82OWD4y4P4trlUK",
    "CELRUSDT": "https://hook.finandy.com/E2q8PleUx0Clrjn-rlUK",
    "CELRUSDTS": "https://hook.finandy.com/oYAmmkFkTKq5cz7-rlUK",
    "CKBUSDT": "https://hook.finandy.com/mKHiVM5w3QCqJ0f5rlUK",
    "CKBUSDTS": "https://hook.finandy.com/b4zcdlFQlxDkSUT5rlUK",
    "COSUSDT": "https://hook.finandy.com/73omqoO70CTVXvwtrlUK",
    "COSUSDTS": "https://hook.finandy.com/WtiT7uH62Cjicv0trlUK",
    "DEGENUSDT": "https://hook.finandy.com/ZoBsmeXKzXHw3zDerlUK",
    "DEGENUSDTS": "https://hook.finandy.com/g4V2H5Kj6ng4gTHerlUK",
    "DENTUSDT": "https://hook.finandy.com/0WRavvY9biMkgPMtrlUK",
    "DENTUSDTS": "https://hook.finandy.com/ISVXOhtIabW3lfAtrlUK",
    "PTBUSDT": "https://hook.finandy.com/L0m_xYpcNeUuQYH4rlUK",
    "PTBUSDTS": "https://hook.finandy.com/LMXJJ72EFfoE4Ib4rlUK",
    "DOGSUSDT": "https://hook.finandy.com/mxgs6_cHVKKbY8YhrlUK",
    "DOGSUSDTS": "https://hook.finandy.com/rOo7l98bSAg0WschrlUK",
    "DOODUSDT": "https://hook.finandy.com/78octjd6rqzYLjL-rlUK",
    "DOODUSDTS": "https://hook.finandy.com/AuBB1OrOASJHQjP-rlUK",
    "TOSHIUSDT": "https://hook.finandy.com/P20hv2o1EeOCdVY1rlUK",
    "TOSHIUSDTS": "https://hook.finandy.com/hnMDzgChuIMYeVc1rlUK",
    "FUNUSDT": "https://hook.finandy.com/FIUiR1IcxvWXg-74rlUK",
    "FUNUSDTS": "https://hook.finandy.com/WeGAwI45NLdRIuz4rlUK",
    "FUSDT": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "FUSDTS": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "HIPPOUSDT": "https://hook.finandy.com/3-VIPLYwTT_XtY7_rlUK",
    "HIPPOUSDTS": "https://hook.finandy.com/6gIuSVhToG1QZ4__rlUK",
    "HMSTRUSDT": "https://hook.finandy.com/C_Exh3VRAtItxcIKrlUK",
    "HMSTRUSDTS": "https://hook.finandy.com/ASzznQdKSKvTm8MKrlUK",
    "HOTUSDT": "https://hook.finandy.com/Qd9tI_oAai-O6yYgrlUK",
    "HOTUSDTS": "https://hook.finandy.com/6amhMUdQG3laMCcgrlUK",
    "IOSTUSDT": "https://hook.finandy.com/TbocZZQl062XLMcCrlUK",
    "IOSTUSDTS": "https://hook.finandy.com/kFrYgZyWL14zqsQCrlUK",
    "LEVERUSDT": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "LEVERUSDTS": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "MEMEUSDT": "https://hook.finandy.com/l_LcerLhBB94_qgWrlUK",
    "MEMEUSDTS": "https://hook.finandy.com/d9S-G2jUp1coJKkWrlUK",
    "MEWUSDT": "https://hook.finandy.com/7O15qM2ob8JQKhwNrlUK",
    "MEWUSDTS": "https://hook.finandy.com/Iglvjwiy5jvnFB0NrlUK",
    "NEIROUSDT": "https://hook.finandy.com/_03ZicWPN_n1DRs0rlUK",
    "NEIROUSDTS": "https://hook.finandy.com/9iD3KT2sKOgGdhg0rlUK",
    "TOWNSUSDT": "https://hook.finandy.com/ptmBF5EjFn4mqTX8rlUK",
    "TOWNSUSDTS": "https://hook.finandy.com/tY3hP1Si-ndJ6gr8rlUK",
    "NOTUSDT": "https://hook.finandy.com/1cvd7IPoCnv1Ly0BrlUK",
    "NOTUSDTS": "https://hook.finandy.com/gGyHVX1KYXrmcCcBrlUK",
    "ONEUSDT": "https://hook.finandy.com/Si6RP6TjxZZUIH75rlUK",
    "ONEUSDTS": "https://hook.finandy.com/VAs8O2qqa7jfOX_5rlUK",
    "PUMPUSDT": "https://hook.finandy.com/WXWYMgd52xHsd3__rlUK",
    "PUMPUSDTS": "https://hook.finandy.com/JUMptnFmcCRHfXz_rlUK",
    "REZUSDT": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "REZUSDTS": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "RSRUSDT": "https://hook.finandy.com/KNpzFD8q9jwk_rg1rlUK",
    "RSRUSDTS": "https://hook.finandy.com/fh2GgaLX42ohhLk1rlUK",
    "SPELLUSDT": "https://hook.finandy.com/G6aXQMYcICy7fj8grlUK",
    "SPELLUSDTS": "https://hook.finandy.com/P3un26JCdqtnyTwgrlUK",
    "AKEUSDT": "https://hook.finandy.com/t7CL16DKN3y4gM7rrlUK",
    "AKEUSDTS": "https://hook.finandy.com/YpkjwyP7yHQC_THrrlUK",
    "TAGUSDT": "https://hook.finandy.com/daUsKIeoxz2QBw0grlUK",
    "TAGUSDTS": "https://hook.finandy.com/xjlhjmkMp8P6NgIgrlUK",
    "TLMUSDT": "https://hook.finandy.com/4N-tpFdE0OAl8Qr7rlUK",
    "TLMUSDTS": "https://hook.finandy.com/TT0qsdmWK7MJgQv7rlUK",
    "TURBOUSDT": "https://hook.finandy.com/26aJyAfUjChC8fgWrlUK",
    "TURBOUSDTS": "https://hook.finandy.com/TRY3KwYjRR2JGvkWrlUK",
    "VTHOUSDT": "https://hook.finandy.com/NwdY1tNyGZQ43f4MrlUK",
    "VTHOUSDTS": "https://hook.finandy.com/WXyOhFD6o7q_ov8MrlUK",
    "XVGUSDT": "https://hook.finandy.com/mEE7zt8Dxm1ChQj7rlUK",
    "XVGUSDTS": "https://hook.finandy.com/eorucMVltQjPNQn7rlUK"
}

# –ó–∞–ø–æ–ª–Ω—è–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –≤–µ–±—Ö—É–∫–∏ –∑–∞–≥–ª—É—à–∫–∞–º–∏
for symbol in INSTRUMENTS:
    if symbol not in FINANDY_WEBHOOKS:
        FINANDY_WEBHOOKS[symbol] = f"https://hook.finandy.com/PLACEHOLDER_{symbol}"

# –û—á–µ—Ä–µ–¥–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
queues = {symbol: asyncio.Queue() for symbol in INSTRUMENTS}


# --- –†–∞–±–æ—Ç–∞ —Å –ë–î ---
def init_db():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS signals (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT,
            name TEXT,
            data TEXT,
            status TEXT,
            created_at REAL,
            sent_at REAL,
            response_code INTEGER,
            response_text TEXT
        )
    """)
    conn.commit()
    conn.close()


def log_signal(symbol: str, name: str, data: dict, status: str, created_at: float,
               sent_at: float | None = None, response_code: int = None,
               response_text: str = None):
    """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞ –≤ –ë–î"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute(
        """INSERT INTO signals 
        (symbol, name, data, status, created_at, sent_at, response_code, response_text) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
        (symbol, name, str(data), status, created_at, sent_at, response_code, response_text)
    )
    conn.commit()
    conn.close()


def get_logs(symbol: str, limit: int = 20):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–≥–æ–≤ –∏–∑ –ë–î"""
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    if symbol == "all":
        cursor.execute("SELECT * FROM signals ORDER BY id DESC LIMIT ?", (limit,))
    else:
        cursor.execute(
            "SELECT * FROM signals WHERE symbol=? OR name=? ORDER BY id DESC LIMIT ?",
            (symbol, symbol, limit)
        )
    rows = cursor.fetchall()
    conn.close()
    return rows


# --- –í–æ—Ä–∫–µ—Ä—ã –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ ---
async def worker(symbol: str):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞"""
    last_sent = 0

    print(f"üöÄ –í–æ—Ä–∫–µ—Ä –∑–∞–ø—É—â–µ–Ω –¥–ª—è {symbol}")

    while True:
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª–∞ –∏ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        data, original_data, name, created_at = await queues[symbol].get()

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–µ–±—Ö—É–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ name –∏–∑ –¥–∞–Ω–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–∞
        target_symbol = name  # –ò—Å–ø–æ–ª—å–∑—É–µ–º name –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–µ–±—Ö—É–∫–∞
        webhook_url = FINANDY_WEBHOOKS.get(target_symbol)

        if not webhook_url:
            error_msg = f"No webhook found for name: {target_symbol}"
            print(f"[{symbol}] ‚ùå {error_msg}")
            log_signal(symbol, name, original_data, f"error {error_msg}", created_at, None, None, error_msg)
            queues[symbol].task_done()
            continue

        now = time.time()

        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ 300 –º—Å –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
        if now - last_sent < 0.3:
            await asyncio.sleep(0.3 - (now - last_sent))

        try:
            # –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            print(f"\n[{symbol}] üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ Finandy:")
            print(f"[{symbol}] Target symbol from name: {target_symbol}")
            print(f"[{symbol}] URL: {webhook_url}")
            print(f"[{symbol}] –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: {original_data}")

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ï –¥–∞–Ω–Ω—ã–µ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
            async with httpx.AsyncClient() as client:
                resp = await client.post(
                    webhook_url,
                    json=original_data,  # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    timeout=10.0
                )

                sent_at = time.time()
                response_text = resp.text[:500]

                # –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞
                print(f"[{symbol}] üì• –û—Ç–≤–µ—Ç –æ—Ç Finandy:")
                print(f"[{symbol}] Status: {resp.status_code}")
                print(f"[{symbol}] Response: {response_text}")

                if resp.status_code == 200:
                    status = f"sent {resp.status_code}"
                    print(f"[{symbol}] ‚úÖ –£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: {resp.status_code}")
                else:
                    status = f"error {resp.status_code}"
                    print(f"[{symbol}] ‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {resp.status_code}")

                # –õ–æ–≥–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                log_signal(symbol, name, original_data, status, created_at, sent_at,
                           resp.status_code, response_text)

        except httpx.TimeoutException as e:
            error_msg = f"Timeout: {str(e)}"
            log_signal(symbol, name, original_data, f"error {error_msg}", created_at, None,
                       None, error_msg)
            print(f"[{symbol}] ‚ùå –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ: {e}")

        except httpx.RequestError as e:
            error_msg = f"Request Error: {str(e)}"
            log_signal(symbol, name, original_data, f"error {error_msg}", created_at, None,
                       None, error_msg)
            print(f"[{symbol}] ‚ùå –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {e}")

        except Exception as e:
            error_msg = f"Unexpected Error: {str(e)}"
            log_signal(symbol, name, original_data, f"error {error_msg}", created_at, None,
                       None, error_msg)
            print(f"[{symbol}] ‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")

        last_sent = time.time()
        queues[symbol].task_done()


# --- Lifespan manager ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    # Startup
    init_db()
    for symbol in queues:
        asyncio.create_task(worker(symbol))
    print(f"üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º {len(INSTRUMENTS)} –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤")
    print("üìã –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Å–∏–º–≤–æ–ª—ã:", INSTRUMENTS)

    yield
    # Shutdown (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å cleanup –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)


# --- FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ ---
app = FastAPI(
    lifespan=lifespan,
    title="Webhook Proxy Server",
    version="1.0",
    description="–ü—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –º–µ–∂–¥—É TradingView –∏ Finandy"
)


# --- –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–´–ô —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –≤—Å–µ—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ ---
@app.post("/webhook", response_model=dict)
async def universal_webhook(signal: TradingSignal):
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –≤–µ–±—Ö—É–∫ –¥–ª—è –ø—Ä–∏–µ–º–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –æ—Ç TradingView

    - **signal**: –î–∞–Ω–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ Finandy
    - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∏–∑ –ø–æ–ª—è 'name' —Å–∏–≥–Ω–∞–ª–∞
    """
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º name –∏–∑ —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ü–µ–ª–µ–≤–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
    target_symbol = signal.name

    if target_symbol not in FINANDY_WEBHOOKS:
        raise HTTPException(
            status_code=404,
            detail=f"Unknown target symbol '{target_symbol}'. Supported symbols: {INSTRUMENTS}"
        )

    # –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    print(f"\nüì© –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª —á–µ—Ä–µ–∑ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –≤–µ–±—Ö—É–∫:")
    print(f"   Target symbol from name: {target_symbol}")
    print(f"   Side: {signal.side}")
    print(f"   Full data: {signal.model_dump()}")

    created_at = time.time()

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –û–†–ò–ì–ò–ù–ê–õ–¨–ù–´–ï –¥–∞–Ω–Ω—ã–µ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    original_data = signal.model_dump()

    # –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
    processed_data = original_data.copy()

    # –õ–æ–≥–∏—Ä—É–µ–º –≤—Ö–æ–¥—è—â–∏–π —Å–∏–≥–Ω–∞–ª —Å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    log_signal("universal", target_symbol, original_data, "received", created_at)

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤ –∫–∞–∫—É—é –æ—á–µ—Ä–µ–¥—å –ø–æ–ª–æ–∂–∏—Ç—å (–∏—Å–ø–æ–ª—å–∑—É–µ–º target_symbol)
    queue_symbol = target_symbol
    if queue_symbol not in queues:
        error_msg = f"No queue found for symbol: {target_symbol}"
        log_signal("universal", target_symbol, original_data, f"error {error_msg}", created_at)
        raise HTTPException(status_code=400, detail=error_msg)

    # –ö–ª–∞–¥–µ–º –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É
    await queues[queue_symbol].put((processed_data, original_data, target_symbol, created_at))

    print(f"[{queue_symbol}] üì© –ü—Ä–∏–Ω—è—Ç —Å–∏–≥–Ω–∞–ª: {signal.side.upper()} –¥–ª—è {target_symbol}")

    return {
        "status": "accepted",
        "target_symbol": target_symbol,
        "queue_symbol": queue_symbol,
        "queued": True,
        "webhook": FINANDY_WEBHOOKS[target_symbol],
        "timestamp": created_at
    }


# --- –°—Ç–∞—Ä—ã–π —ç–Ω–¥–ø–æ–∏–Ω—Ç (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏) ---
@app.post("/webhook/{symbol}", response_model=dict)
async def webhook_with_symbol(symbol: str, signal: TradingSignal):
    """
    –í–µ–±—Ö—É–∫ —Å —É–∫–∞–∑–∞–Ω–∏–µ–º —Å–∏–º–≤–æ–ª–∞ –≤ URL (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
    """
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º name –∏–∑ —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ü–µ–ª–µ–≤–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
    target_symbol = signal.name

    if target_symbol not in FINANDY_WEBHOOKS:
        raise HTTPException(
            status_code=404,
            detail=f"Unknown target symbol {target_symbol}. Supported symbols: {INSTRUMENTS}"
        )

    print(f"\nüì© –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª —á–µ—Ä–µ–∑ –≤–µ–±—Ö—É–∫ —Å —Å–∏–º–≤–æ–ª–æ–º:")
    print(f"   URL symbol: {symbol}")
    print(f"   Target symbol from name: {target_symbol}")
    print(f"   Side: {signal.side}")

    created_at = time.time()
    original_data = signal.model_dump()
    processed_data = original_data.copy()

    log_signal(symbol, target_symbol, original_data, "received", created_at)

    queue_symbol = target_symbol
    if queue_symbol not in queues:
        queue_symbol = symbol
        print(f"‚ö†Ô∏è –û—á–µ—Ä–µ–¥—å –¥–ª—è {target_symbol} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º {symbol}")

    await queues[queue_symbol].put((processed_data, original_data, target_symbol, created_at))

    print(f"[{queue_symbol}] üì© –ü—Ä–∏–Ω—è—Ç —Å–∏–≥–Ω–∞–ª: {signal.side.upper()} –¥–ª—è {target_symbol}")

    return {
        "status": "accepted",
        "url_symbol": symbol,
        "target_symbol": target_symbol,
        "queue_symbol": queue_symbol,
        "queued": True,
        "webhook": FINANDY_WEBHOOKS[target_symbol],
        "timestamp": created_at
    }


# –û—Å—Ç–∞–ª—å–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π...
@app.post("/test-webhook/{symbol}")
async def test_webhook(symbol: str):
    """–¢–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –∫ Finandy –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
    if symbol not in FINANDY_WEBHOOKS:
        return {"error": "Symbol not found"}

    webhook_url = FINANDY_WEBHOOKS[symbol]

    if "PLACEHOLDER" in webhook_url or "XXXXXXXX" in webhook_url:
        return {"error": "Webhook URL is a placeholder", "url": webhook_url}

    test_data = {
        "name": symbol,
        "secret": "test_secret",
        "symbol": symbol,
        "side": "buy",
        "open": {
            "enabled": True,
            "amountType": "sumUsd",
            "amount": "6"
        },
        "dca": {
            "amountType": "sumUsd",
            "amount": "6",
            "checkProfit": False
        },
        "close": {
            "price": "",
            "action": "decrease",
            "decrease": {
                "type": "posAmountPct",
                "amount": "1"
            },
            "checkProfit": True
        },
        "sl": {
            "price": "",
            "update": False
        }
    }

    try:
        print(f"\nüß™ –¢–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –¥–ª—è {symbol}:")
        print(f"URL: {webhook_url}")
        print(f"–î–∞–Ω–Ω—ã–µ: {test_data}")

        async with httpx.AsyncClient() as client:
            resp = await client.post(webhook_url, json=test_data, timeout=10.0)

            result = {
                "status_code": resp.status_code,
                "response": resp.text[:500],
                "url": webhook_url,
                "success": resp.status_code == 200
            }

            print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç: {result}")
            return result

    except Exception as e:
        error_result = {"error": str(e), "url": webhook_url}
        print(f"–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∞: {error_result}")
        return error_result


@app.get("/webhooks", response_model=dict)
async def list_webhooks():
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –≤–µ–±—Ö—É–∫–æ–≤"""
    valid_webhooks = {}
    placeholder_webhooks = {}

    for symbol, url in FINANDY_WEBHOOKS.items():
        if "PLACEHOLDER" in url or "XXXXXXXX" in url:
            placeholder_webhooks[symbol] = url
        else:
            valid_webhooks[symbol] = url

    return {
        "total_instruments": len(INSTRUMENTS),
        "valid_webhooks_count": len(valid_webhooks),
        "placeholder_webhooks_count": len(placeholder_webhooks),
        "valid_webhooks": valid_webhooks,
        "placeholder_webhooks": placeholder_webhooks
    }


@app.get("/instruments", response_model=dict)
async def list_instruments():
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤"""
    return {
        "total": len(INSTRUMENTS),
        "instruments": INSTRUMENTS
    }


@app.get("/logs/{symbol}", response_model=List[dict])
async def logs(symbol: str, limit: int = 20):
    """–ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–∏–≥–Ω–∞–ª—ã –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ"""
    rows = get_logs(symbol, limit)
    columns = ["id", "symbol", "name", "data", "status", "created_at", "sent_at", "response_code", "response_text"]
    results = [dict(zip(columns, row)) for row in rows]
    return results


@app.get("/", response_model=dict)
async def root():
    """–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ API"""
    return {
        "message": "Webhook Proxy Server for Finandy",
        "version": "1.0",
        "total_instruments": len(INSTRUMENTS),
        "endpoints": {
            "universal_webhook": "POST /webhook (–¥–ª—è –≤—Å–µ—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤)",
            "webhook_with_symbol": "POST /webhook/{symbol} (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)",
            "test_webhook": "POST /test-webhook/{symbol}",
            "logs": "GET /logs/{symbol}",
            "webhooks_list": "GET /webhooks",
            "instruments_list": "GET /instruments",
            "health_check": "GET /health",
            "docs": "GET /docs",
            "redoc": "GET /redoc"
        }
    }


@app.get("/health", response_model=dict)
async def health_check():
    """Health check endpoint –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
    active_queues = len([q for q in queues.values() if not q.empty()])
    placeholder_count = len([url for url in FINANDY_WEBHOOKS.values()
                             if "PLACEHOLDER" in url or "XXXXXXXX" in url])

    return {
        "status": "healthy",
        "timestamp": time.time(),
        "instruments_loaded": len(INSTRUMENTS),
        "queues_active": active_queues,
        "placeholder_webhooks": placeholder_count,
        "valid_webhooks": len(INSTRUMENTS) - placeholder_count
    }


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=PORT)

# D:/Stateline/Documents/GitHub/webhook-server\src\__init__.py


# D:/Stateline/Documents/GitHub/webhook-server\src\api\__init__.py


# D:/Stateline/Documents/GitHub/webhook-server\src\api\dependencies.py
from config.settings import settings
from config import webhooks
from database import SignalRepository
from services import QueueManager
from services import WebhookClient

# Dependency injections
def get_settings():
    return settings

def get_webhook_config():
    return webhooks

def get_repository():
    return SignalRepository(settings.db_path)

def get_queue_manager():
    return QueueManager()

def get_webhook_client():
    return WebhookClient()

# D:/Stateline/Documents/GitHub/webhook-server\src\api\endpoints.py
# src/api/endpoints.py
import time
from typing import List, Dict, Any
from fastapi import APIRouter, HTTPException, Depends, Query, Request
from fastapi.responses import HTMLResponse
from config import webhooks
from database.repository import SignalRepository
from services.queue_service import QueueManager
from services.webhook_service import WebhookClient
from core.models import TradingSignal, WebhookResponse, HealthStatus
from core.exceptions import QueueNotFoundException


router = APIRouter()


# === –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏: –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –æ–±—â–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä—ã –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ===

def get_repository(request: Request) -> SignalRepository:
    return request.app.state.repository

def get_queue_manager(request: Request) -> QueueManager:
    return request.app.state.queue_manager

def get_webhook_client(request: Request) -> WebhookClient:
    return request.app.state.webhook_client


# === –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã ===

@router.post("/webhook", response_model=WebhookResponse)
async def universal_webhook(
    signal: TradingSignal,
    repository: SignalRepository = Depends(get_repository),
    queue_manager: QueueManager = Depends(get_queue_manager),
):
    return await _process_webhook(signal, None, repository, queue_manager)


@router.post("/webhook/{symbol}", response_model=WebhookResponse)
async def webhook_with_symbol(
    symbol: str,
    signal: TradingSignal,
    repository: SignalRepository = Depends(get_repository),
    queue_manager: QueueManager = Depends(get_queue_manager),
):
    return await _process_webhook(signal, symbol, repository, queue_manager)


async def _process_webhook(
    signal: TradingSignal,
    url_symbol: str,
    repository: SignalRepository,
    queue_manager: QueueManager,
) -> WebhookResponse:
    target_symbol = signal.name

    if target_symbol not in webhooks.FINANDY_WEBHOOKS:
        supported_symbols = webhooks.get_supported_instruments()[:10]
        raise HTTPException(
            status_code=404,
            detail={
                "error": f"Unknown target symbol '{target_symbol}'",
                "supported_symbols_sample": supported_symbols,
                "total_supported": len(webhooks.get_supported_instruments()),
            },
        )

    print(f"\nüì© –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª:")
    print(f"   URL symbol: {url_symbol}")
    print(f"   Target symbol from name: {target_symbol}")
    print(f"   Side: {signal.side}")

    created_at = time.time()
    original_data = signal.model_dump()

    log_symbol = url_symbol or "universal"
    repository.log_signal(log_symbol, target_symbol, original_data, "received", created_at)

    queue_symbol = target_symbol
    if queue_symbol not in webhooks.get_supported_instruments():
        queue_symbol = url_symbol
        print(f"‚ö†Ô∏è –û—á–µ—Ä–µ–¥—å –¥–ª—è {target_symbol} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º {url_symbol}")

    if not queue_symbol or queue_symbol not in webhooks.get_supported_instruments():
        error_msg = f"No queue available for symbol: {target_symbol}"
        repository.log_signal(log_symbol, target_symbol, original_data, f"error {error_msg}", created_at)
        raise HTTPException(status_code=400, detail=error_msg)

    try:
        print(f"üì• –ö–ª–∞–¥—É —Å–∏–≥–Ω–∞–ª –≤ –æ—á–µ—Ä–µ–¥—å: {queue_symbol}")
        await queue_manager.put(
            queue_symbol,
            (original_data.copy(), original_data, target_symbol, created_at),
        )
        print(f"[{queue_symbol}] ‚úÖ –°–∏–≥–Ω–∞–ª –ø–æ–ª–æ–∂–µ–Ω –≤ –æ—á–µ—Ä–µ–¥—å")
    except QueueNotFoundException as e:
        raise HTTPException(status_code=400, detail=str(e))

    print(f"[{queue_symbol}] üì© –ü—Ä–∏–Ω—è—Ç —Å–∏–≥–Ω–∞–ª: {signal.side.upper()} –¥–ª—è {target_symbol}")

    return WebhookResponse(
        status="accepted",
        target_symbol=target_symbol,
        queue_symbol=queue_symbol,
        queued=True,
        webhook=webhooks.get_webhook_url(target_symbol),
        timestamp=created_at,
    )


@router.post("/test-webhook/{symbol}")
async def test_webhook(
    symbol: str,
    webhook_client: WebhookClient = Depends(get_webhook_client),
):
    if symbol not in webhooks.FINANDY_WEBHOOKS:
        return {
            "error": "Symbol not found",
            "supported_symbols": webhooks.get_supported_instruments()[:5],
        }

    webhook_url = webhooks.get_webhook_url(symbol)

    if not webhooks.is_valid_webhook(webhook_url):
        return {
            "error": "Webhook URL is a placeholder",
            "url": webhook_url,
            "message": "Please configure a valid webhook URL for this symbol",
        }

    test_data = {
        "name": symbol,
        "secret": "test_secret",
        "symbol": symbol,
        "side": "buy",
        "open": {"enabled": True, "amountType": "sumUsd", "amount": "6"},
        "dca": {"amountType": "sumUsd", "amount": "6", "checkProfit": False},
        "close": {
            "price": "",
            "action": "decrease",
            "decrease": {"type": "posAmountPct", "amount": "1"},
            "checkProfit": True,
        },
        "sl": {"price": "", "update": False},
    }

    try:
        print(f"\nüß™ –¢–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –¥–ª—è {symbol}:")
        status_code, response_text = await webhook_client.send(webhook_url, test_data)

        return {
            "status_code": status_code,
            "response": response_text,
            "url": webhook_url,
            "success": status_code == 200,
            "symbol": symbol,
        }

    except Exception as e:
        return {"error": str(e), "url": webhook_url, "symbol": symbol}


@router.get("/webhooks", response_model=Dict[str, Any])
async def list_webhooks():
    valid_webhooks = {}
    placeholder_webhooks = {}

    for symbol, url in webhooks.FINANDY_WEBHOOKS.items():
        if webhooks.is_valid_webhook(url):
            valid_webhooks[symbol] = url
        else:
            placeholder_webhooks[symbol] = url

    return {
        "total_instruments": len(webhooks.get_supported_instruments()),
        "valid_webhooks_count": len(valid_webhooks),
        "placeholder_webhooks_count": len(placeholder_webhooks),
        "valid_webhooks": valid_webhooks,
        "placeholder_webhooks": placeholder_webhooks,
    }


@router.get("/instruments", response_model=Dict[str, Any])
async def list_instruments():
    instruments = webhooks.get_supported_instruments()
    return {"total": len(instruments), "instruments": instruments}


@router.get("/logs/{symbol}", response_model=List[Dict[str, Any]])
async def get_logs_json(
    symbol: str,
    limit: int = Query(20, ge=1, le=100),
    repository: SignalRepository = Depends(get_repository),
):
    try:
        rows = repository.get_logs(symbol, limit)
        columns = [
            "id",
            "symbol",
            "name",
            "data",
            "status",
            "created_at",
            "sent_at",
            "response_code",
            "response_text",
        ]

        results = []
        for row in rows:
            result_dict = dict(zip(columns, row))
            if result_dict["created_at"]:
                result_dict["created_at_readable"] = time.ctime(result_dict["created_at"])
            if result_dict["sent_at"]:
                result_dict["sent_at_readable"] = time.ctime(result_dict["sent_at"])
            results.append(result_dict)

        return results
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving logs: {str(e)}")


@router.get("/logs/html/{symbol}", response_class=HTMLResponse)
async def get_logs_html(
    symbol: str,
    limit: int = Query(20, ge=1, le=100),
    repository: SignalRepository = Depends(get_repository),
):
    try:
        rows = repository.get_logs(symbol, limit)
        columns = [
            "id",
            "symbol",
            "name",
            "data",
            "status",
            "created_at",
            "sent_at",
            "response_code",
            "response_text",
        ]

        html_template = """<!DOCTYPE html>
<html>
<head>
    <title>Webhook Logs - {symbol}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }}
        .container {{ max-width: 1400px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        h2 {{ color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }}
        table {{ border-collapse: collapse; width: 100%; margin-top: 20px; font-size: 14px; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; word-break: break-all; }}
        th {{ background-color: #007bff; color: white; font-weight: bold; }}
        tr:nth-child(even) {{ background-color: #f9f9f9; }}
        tr:hover {{ background-color: #f1f1f1; }}
    </style>
</head>
<body>
    <div class="container">
        <h2>üìä Webhook Logs: {symbol}</h2>
        <p>üîÑ Total instruments: {total_count} | üìã Showing: {row_count} records</p>
        <table>
            <thead><tr>{headers}</tr></thead>
            <tbody>{rows}</tbody>
        </table>
    </div>
</body>
</html>"""

        headers = "".join(f"<th>{col.upper()}</th>" for col in columns)
        rows_html = "".join(
            f"<tr>{''.join(f'<td>{cell}</td>' for cell in row)}</tr>" for row in rows
        )

        return HTMLResponse(
            content=html_template.format(
                symbol=symbol,
                total_count=len(webhooks.get_supported_instruments()),
                row_count=len(rows),
                headers=headers,
                rows=rows_html,
            )
        )

    except Exception as e:
        error_html = f"<html><body><div style='color: red; padding: 20px;'><h2>Error loading logs</h2><p>{str(e)}</p></div></body></html>"
        return HTMLResponse(content=error_html, status_code=500)


@router.get("/health", response_model=HealthStatus)
async def health_check(
    queue_manager: QueueManager = Depends(get_queue_manager),
):
    placeholder_count = sum(
        1 for url in webhooks.FINANDY_WEBHOOKS.values() if not webhooks.is_valid_webhook(url)
    )

    return HealthStatus(
        status="healthy",
        timestamp=time.time(),
        instruments_loaded=len(webhooks.get_supported_instruments()),
        queues_active=queue_manager.get_active_queues_count(),
        placeholder_webhooks=placeholder_count,
        valid_webhooks=len(webhooks.get_supported_instruments()) - placeholder_count,
    )


@router.get("/", response_model=Dict[str, Any])
async def root():
    return {
        "message": "Webhook Proxy Server for Finandy",
        "version": "1.0",
        "total_instruments": len(webhooks.get_supported_instruments()),
        "endpoints": {
            "universal_webhook": "POST /api/v1/webhook",
            "webhook_with_symbol": "POST /api/v1/webhook/{symbol}",
            "test_webhook": "POST /api/v1/test-webhook/{symbol}",
            "logs_json": "GET /api/v1/logs/{symbol}",
            "logs_html": "GET /api/v1/logs/html/{symbol}",
            "webhooks_list": "GET /api/v1/webhooks",
            "instruments_list": "GET /api/v1/instruments",
            "health_check": "GET /api/v1/health",
            "docs": "/docs",
        },
    }


@router.get("/stats", response_model=Dict[str, Any])
async def get_stats(
    repository: SignalRepository = Depends(get_repository),
):
    try:
        rows = repository.get_logs("all", 1000)

        if not rows:
            return {"message": "No data available for statistics"}

        stats = {
            "total_signals": len(rows),
            "status_distribution": {},
            "symbol_distribution": {},
            "recent_activity": {},
        }

        for row in rows:
            status = row[4]
            symbol = row[1]
            created_at = row[5]

            stats["status_distribution"][status] = stats["status_distribution"].get(status, 0) + 1
            stats["symbol_distribution"][symbol] = stats["symbol_distribution"].get(symbol, 0) + 1

            if time.time() - created_at <= 86400:
                hour = time.strftime("%H:00", time.localtime(created_at))
                stats["recent_activity"][hour] = stats["recent_activity"].get(hour, 0) + 1

        stats["status_distribution"] = dict(
            sorted(stats["status_distribution"].items(), key=lambda x: x[1], reverse=True)
        )
        stats["symbol_distribution"] = dict(
            sorted(stats["symbol_distribution"].items(), key=lambda x: x[1], reverse=True)[:10]
        )
        stats["recent_activity"] = dict(sorted(stats["recent_activity"].items()))

        return stats

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating stats: {str(e)}")

# D:/Stateline/Documents/GitHub/webhook-server\src\check_structure.py
# src/check_structure.py
import os

print("=== Project Structure Check ===")

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤
files_to_check = [
    'core/__init__.py',
    'core/models.py',
    'core/exceptions.py',
    'api/__init__.py',
    'api/endpoints.py',
    'main.py'
]

for file in files_to_check:
    exists = os.path.exists(file)
    print(f"{'‚úÖ' if exists else '‚ùå'} {file}: {'Exists' if exists else 'Missing'}")

print("\n=== core/__init__.py content ===")
try:
    with open('core/__init__.py', 'r') as f:
        content = f.read()
        print(content)
except Exception as e:
    print(f"Error reading core/__init__.py: {e}")

print("\n=== Import test ===")
try:
    from core.models import TradingSignal
    print("‚úÖ TradingSignal imports successfully")
except ImportError as e:
    print(f"‚ùå TradingSignal import failed: {e}")

try:
    from core.exceptions import QueueNotFoundException
    print("‚úÖ QueueNotFoundException imports successfully")
except ImportError as e:
    print(f"‚ùå QueueNotFoundException import failed: {e}")

# D:/Stateline/Documents/GitHub/webhook-server\src\config\__init__.py
from config.webhooks import (  # ‚úÖ –ë–µ–∑ —Ç–æ—á–µ–∫
    FINANDY_WEBHOOKS,
    get_supported_instruments,
    get_webhook_url,
    is_valid_webhook
)

# D:/Stateline/Documents/GitHub/webhook-server\src\config\settings.py
import os
from typing import Dict, Any


class Settings:
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""

    def __init__(self):
        self.db_path = os.getenv("DB_PATH", "signals.db")
        self.port = int(os.getenv("PORT", "8001"))
        self.rate_limit_ms = float(os.getenv("RATE_LIMIT_MS", "300"))
        self.request_timeout = float(os.getenv("REQUEST_TIMEOUT", "10.0"))
        self.log_limit = int(os.getenv("LOG_LIMIT", "20"))


settings = Settings()

# D:/Stateline/Documents/GitHub/webhook-server\src\config\webhooks.py
"""–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≤–µ–±—Ö—É–∫–æ–≤ Finandy"""

FINANDY_WEBHOOKS = {
    "1MBABYDOGEUSDT": "https://hook.finandy.com/TuaL5bAQjTO2kP4trlUK",
    "1MBABYDOGEUSDTS": "https://hook.finandy.com/09V1WmbUktZCq_8trlUK",
    "1000CATUSDT": "https://hook.finandy.com/iFh_Ic-r0LeOFkz5rlUK",
    "1000CATUSDTS": "https://hook.finandy.com/dPpzETmR50zRbU35rlUK",
    "1000CHEEMSUSDT": "https://hook.finandy.com/oGKYnFSG8EcfFUUXrlUK",
    "1000CHEEMSUSDTS": "https://hook.finandy.com/qoOE5ObxuJ9fVFoXrlUK",
    "1000PEPEUSDT": "https://hook.finandy.com/0O0Famu12xI3IT7ZrlUK",
    "1000PEPEUSDTS": "https://hook.finandy.com/jmpa1C-AJJB2vD_ZrlUK",
    "1000RATSUSDT": "https://hook.finandy.com/l8JsSEjNzZd0CTzZrlUK",
    "1000RATSUSDTS": "https://hook.finandy.com/QcFtY7IJXTyUuD3ZrlUK",
    "1000SATSUSDT": "https://hook.finandy.com/dMOLd-EEPHPv84ICrlUK",
    "1000SATSUSDTS": "https://hook.finandy.com/y-ihQVJF3B_TYoMCrlUK",
    "1000WHYUSDT": "https://hook.finandy.com/vD6Y-C5FcYVTF5clrlUK",
    "1000WHYUSDTS": "https://hook.finandy.com/HmIQ65EkmnIe0ZQlrlUK",
    "B3USDT": "https://hook.finandy.com/3BD-SHeKq6e-90P5rlUK",
    "B3USDTS": "https://hook.finandy.com/mPjmmUyexOLbrkD5rlUK",
    "BANANAS31USDT": "https://hook.finandy.com/2-mBZ4Wlq8LXvkjyrlUK",
    "BANANAS31USDTS": "https://hook.finandy.com/XgZw33-Ev83LI0nyrlUK",
    "BEAMXUSDT": "https://hook.finandy.com/8WdHzLmWBXeiMKQ1rlUK",
    "BEAMXUSDTS": "https://hook.finandy.com/2GJI0BxNg1tMpqU1rlUK",
    "BOMEUSDT": "https://hook.finandy.com/3Z-yX4GNQeM4qPACrlUK",
    "BOMEUSDTS": "https://hook.finandy.com/_QAms23yOJcA7fECrlUK",
    "BROCCOLIF3BUSDT": "https://hook.finandy.com/w-SfCLt30P5Z9IL4rlUK",
    "BROCCOLIF3BUSDTS": "https://hook.finandy.com/8_YNXd82OWD4y4P4trlUK",
    "CELRUSDT": "https://hook.finandy.com/E2q8PleUx0Clrjn-rlUK",
    "CELRUSDTS": "https://hook.finandy.com/oYAmmkFkTKq5cz7-rlUK",
    "CKBUSDT": "https://hook.finandy.com/mKHiVM5w3QCqJ0f5rlUK",
    "CKBUSDTS": "https://hook.finandy.com/b4zcdlFQlxDkSUT5rlUK",
    "COSUSDT": "https://hook.finandy.com/73omqoO70CTVXvwtrlUK",
    "COSUSDTS": "https://hook.finandy.com/WtiT7uH62Cjicv0trlUK",
    "DEGENUSDT": "https://hook.finandy.com/ZoBsmeXKzXHw3zDerlUK",
    "DEGENUSDTS": "https://hook.finandy.com/g4V2H5Kj6ng4gTHerlUK",
    "DENTUSDT": "https://hook.finandy.com/0WRavvY9biMkgPMtrlUK",
    "DENTUSDTS": "https://hook.finandy.com/ISVXOhtIabW3lfAtrlUK",
    "PTBUSDT": "https://hook.finandy.com/L0m_xYpcNeUuQYH4rlUK",
    "PTBUSDTS": "https://hook.finandy.com/LMXJJ72EFfoE4Ib4rlUK",
    "DOGSUSDT": "https://hook.finandy.com/mxgs6_cHVKKbY8YhrlUK",
    "DOGSUSDTS": "https://hook.finandy.com/rOo7l98bSAg0WschrlUK",
    "DOODUSDT": "https://hook.finandy.com/78octjd6rqzYLjL-rlUK",
    "DOODUSDTS": "https://hook.finandy.com/AuBB1OrOASJHQjP-rlUK",
    "TOSHIUSDT": "https://hook.finandy.com/P20hv2o1EeOCdVY1rlUK",
    "TOSHIUSDTS": "https://hook.finandy.com/hnMDzgChuIMYeVc1rlUK",
    "FUNUSDT": "https://hook.finandy.com/FIUiR1IcxvWXg-74rlUK",
    "FUNUSDTS": "https://hook.finandy.com/WeGAwI45NLdRIuz4rlUK",
    "FUSDT": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "FUSDTS": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "HIPPOUSDT": "https://hook.finandy.com/3-VIPLYwTT_XtY7_rlUK",
    "HIPPOUSDTS": "https://hook.finandy.com/6gIuSVhToG1QZ4__rlUK",
    "HMSTRUSDT": "https://hook.finandy.com/C_Exh3VRAtItxcIKrlUK",
    "HMSTRUSDTS": "https://hook.finandy.com/ASzznQdKSKvTm8MKrlUK",
    "HOTUSDT": "https://hook.finandy.com/Qd9tI_oAai-O6yYgrlUK",
    "HOTUSDTS": "https://hook.finandy.com/6amhMUdQG3laMCcgrlUK",
    "IOSTUSDT": "https://hook.finandy.com/TbocZZQl062XLMcCrlUK",
    "IOSTUSDTS": "https://hook.finandy.com/kFrYgZyWL14zqsQCrlUK",
    "LEVERUSDT": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "LEVERUSDTS": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "MEMEUSDT": "https://hook.finandy.com/l_LcerLhBB94_qgWrlUK",
    "MEMEUSDTS": "https://hook.finandy.com/d9S-G2jUp1coJKkWrlUK",
    "MEWUSDT": "https://hook.finandy.com/7O15qM2ob8JQKhwNrlUK",
    "MEWUSDTS": "https://hook.finandy.com/Iglvjwiy5jvnFB0NrlUK",
    "NEIROUSDT": "https://hook.finandy.com/_03ZicWPN_n1DRs0rlUK",
    "NEIROUSDTS": "https://hook.finandy.com/9iD3KT2sKOgGdhg0rlUK",
    "TOWNSUSDT": "https://hook.finandy.com/ptmBF5EjFn4mqTX8rlUK",
    "TOWNSUSDTS": "https://hook.finandy.com/tY3hP1Si-ndJ6gr8rlUK",
    "NOTUSDT": "https://hook.finandy.com/1cvd7IPoCnv1Ly0BrlUK",
    "NOTUSDTS": "https://hook.finandy.com/gGyHVX1KYXrmcCcBrlUK",
    "ONEUSDT": "https://hook.finandy.com/Si6RP6TjxZZUIH75rlUK",
    "ONEUSDTS": "https://hook.finandy.com/VAs8O2qqa7jfOX_5rlUK",
    "PUMPUSDT": "https://hook.finandy.com/WXWYMgd52xHsd3__rlUK",
    "PUMPUSDTS": "https://hook.finandy.com/JUMptnFmcCRHfXz_rlUK",
    "REZUSDT": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "REZUSDTS": "https://hook.finandy.com/XXXXXXXXXXXXXXX",
    "RSRUSDT": "https://hook.finandy.com/KNpzFD8q9jwk_rg1rlUK",
    "RSRUSDTS": "https://hook.finandy.com/fh2GgaLX42ohhLk1rlUK",
    "SPELLUSDT": "https://hook.finandy.com/G6aXQMYcICy7fj8grlUK",
    "SPELLUSDTS": "https://hook.finandy.com/P3un26JCdqtnyTwgrlUK",
    "AKEUSDT": "https://hook.finandy.com/t7CL16DKN3y4gM7rrlUK",
    "AKEUSDTS": "https://hook.finandy.com/YpkjwyP7yHQC_THrrlUK",
    "TAGUSDT": "https://hook.finandy.com/daUsKIeoxz2QBw0grlUK",
    "TAGUSDTS": "https://hook.finandy.com/xjlhjmkMp8P6NgIgrlUK",
    "TLMUSDT": "https://hook.finandy.com/4N-tpFdE0OAl8Qr7rlUK",
    "TLMUSDTS": "https://hook.finandy.com/TT0qsdmWK7MJgQv7rlUK",
    "TURBOUSDT": "https://hook.finandy.com/26aJyAfUjChC8fgWrlUK",
    "TURBOUSDTS": "https://hook.finandy.com/TRY3KwYjRR2JGvkWrlUK",
    "VTHOUSDT": "https://hook.finandy.com/NwdY1tNyGZQ43f4MrlUK",
    "VTHOUSDTS": "https://hook.finandy.com/WXyOhFD6o7q_ov8MrlUK",
    "XVGUSDT": "https://hook.finandy.com/mEE7zt8Dxm1ChQj7rlUK",
    "XVGUSDTS": "https://hook.finandy.com/eorucMVltQjPNQn7rlUK"
}


def get_supported_instruments() -> list[str]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤"""
    return list(FINANDY_WEBHOOKS.keys())


def get_webhook_url(symbol: str) -> str:
    """–ü–æ–ª—É—á–∏—Ç—å URL –≤–µ–±—Ö—É–∫–∞ –¥–ª—è —Å–∏–º–≤–æ–ª–∞"""
    normalized = symbol.strip().upper()   # ‚ú® –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
    url = FINANDY_WEBHOOKS.get(normalized)

    if not url:
        print(f"[webhooks.py] ‚ö†Ô∏è –°–∏–º–≤–æ–ª '{symbol}' (–Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω: '{normalized}') –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ FINANDY_WEBHOOKS")
        return None

    if "PLACEHOLDER" in url or "XXXXXXXX" in url:
        return f"https://hook.finandy.com/PLACEHOLDER_{normalized}"

    return url


def is_valid_webhook(url: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –≤–µ–±—Ö—É–∫ –≤–∞–ª–∏–¥–Ω—ã–º (–Ω–µ –∑–∞–≥–ª—É—à–∫–æ–π)"""
    return url and "PLACEHOLDER" not in url and "XXXXXXXX" not in url


# D:/Stateline/Documents/GitHub/webhook-server\src\core\__init__.py
# src/core/__init__.py
from core.models import TradingSignal, WebhookResponse, HealthStatus  # ‚úÖ –ë–µ–∑ —Ç–æ—á–µ–∫
from core.exceptions import QueueNotFoundException, WebhookSendException  # ‚úÖ –ë–µ–∑ —Ç–æ—á–µ–∫

__all__ = [
    "TradingSignal",
    "WebhookResponse",
    "HealthStatus",
    "QueueNotFoundException",
    "WebhookSendException"
]

# D:/Stateline/Documents/GitHub/webhook-server\src\core\exceptions.py
class WebhookException(Exception):
    """–ë–∞–∑–æ–≤–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è –≤–µ–±—Ö—É–∫–æ–≤"""
    pass

class SymbolNotFoundException(WebhookException):
    """–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤"""
    pass

class WebhookSendException(WebhookException):
    """–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤–µ–±—Ö—É–∫–∞"""
    pass

class QueueNotFoundException(WebhookException):
    """–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö –æ—á–µ—Ä–µ–¥–µ–π"""
    pass

# D:/Stateline/Documents/GitHub/webhook-server\src\core\models.py
from typing import List, Dict, Any, Optional
from pydantic import BaseModel

class CloseDecrease(BaseModel):
    type: str
    amount: str

class CloseOrder(BaseModel):
    action: str
    decrease: CloseDecrease
    checkProfit: bool
    price: str = ""

class OpenOrder(BaseModel):
    amountType: str
    amount: str
    enabled: bool

class DCAOrder(BaseModel):
    amountType: str
    amount: str
    checkProfit: bool

class SLConfig(BaseModel):
    price: str = ""
    update: bool

class TradingSignal(BaseModel):
    name: str
    secret: str
    side: str
    symbol: str
    close: CloseOrder
    open: OpenOrder
    dca: DCAOrder
    sl: SLConfig
    tp: Optional[Dict[str, Any]] = None

class WebhookResponse(BaseModel):
    status: str
    target_symbol: str
    queue_symbol: str
    queued: bool
    webhook: str
    timestamp: float

class HealthStatus(BaseModel):
    status: str
    timestamp: float
    instruments_loaded: int
    queues_active: int
    placeholder_webhooks: int
    valid_webhooks: int

# D:/Stateline/Documents/GitHub/webhook-server\src\database\__init__.py
# src/database/__init__.py
from database.repository import SignalRepository  # ‚úÖ –ë–µ–∑ —Ç–æ—á–µ–∫

__all__ = ["SignalRepository"]

# D:/Stateline/Documents/GitHub/webhook-server\src\database\repository.py
import sqlite3
import os
from typing import List, Optional


class SignalRepository:
    """–†–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–∏–≥–Ω–∞–ª–∞–º–∏ –≤ –ë–î"""

    def __init__(self, db_path: str = None):
        self.db_path = db_path or os.getenv('DB_PATH', '/app/data/signals.db')
        self.log_limit = int(os.getenv('LOG_LIMIT', '50'))

    def init_db(self) -> None:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS signals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT,
                name TEXT,
                data TEXT,
                status TEXT,
                created_at REAL,
                sent_at REAL,
                response_code INTEGER,
                response_text TEXT
            )
        """)
        conn.commit()
        conn.close()

    def log_signal(self, symbol: str, name: str, data: dict, status: str,
                   created_at: float, sent_at: Optional[float] = None,
                   response_code: Optional[int] = None, response_text: Optional[str] = None) -> None:
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞ –≤ –ë–î"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute(
            """INSERT INTO signals 
            (symbol, name, data, status, created_at, sent_at, response_code, response_text) 
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
            (symbol, name, str(data), status, created_at, sent_at, response_code, response_text)
        )
        conn.commit()
        conn.close()

    def get_logs(self, symbol: str, limit: int = None) -> List[tuple]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–≥–æ–≤ –∏–∑ –ë–î"""
        if limit is None:
            limit = self.log_limit

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        if symbol == "all":
            cursor.execute("SELECT * FROM signals ORDER BY id DESC LIMIT ?", (limit,))
        else:
            cursor.execute(
                "SELECT * FROM signals WHERE symbol=? OR name=? ORDER BY id DESC LIMIT ?",
                (symbol, symbol, limit)
            )
        rows = cursor.fetchall()
        conn.close()
        return rows

# D:/Stateline/Documents/GitHub/webhook-server\src\debug_imports.py
# src/debug_imports.py
import os
import sys

print("=== Debug Imports ===")
print("Current directory:", os.getcwd())
print("Python path:", sys.path)

print("\n=== Checking core module ===")
try:
    import core
    print("core module found")
    print("core contents:", dir(core))
except ImportError as e:
    print("core import error:", e)

print("\n=== Checking core.models ===")
try:
    import core.models
    print("core.models found")
    print("core.models contents:", dir(core.models))
except ImportError as e:
    print("core.models import error:", e)

print("\n=== Direct import test ===")
try:
    from core.models import TradingSignal
    print("‚úÖ Direct import from core.models works")
except ImportError as e:
    print("‚ùå Direct import failed:", e)

# D:/Stateline/Documents/GitHub/webhook-server\src\main.py
# src/main.py
import asyncio
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from config.settings import settings
from config import webhooks
from database.repository import SignalRepository
from services.webhook_service import WebhookClient
from services.worker_service import SignalWorker
from api.endpoints import router as api_router
from services.queue_service import QueueManager


@asynccontextmanager
async def lifespan(app: FastAPI):
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
    repository = SignalRepository()
    queue_manager = QueueManager()
    webhook_client = WebhookClient()

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
    repository.init_db()

    # –ó–∞–ø—É—Å–∫ –≤–æ—Ä–∫–µ—Ä–æ–≤
    workers = []
    worker_tasks = []
    instruments = webhooks.get_supported_instruments()

    for symbol in instruments:
        try:
            worker = SignalWorker(symbol, queue_manager, repository, webhook_client)
            workers.append(worker)
            task = asyncio.create_task(worker.run())
            worker_tasks.append(task)
            print(f"‚úÖ –í–æ—Ä–∫–µ—Ä –∑–∞–ø—É—â–µ–Ω –¥–ª—è {symbol}")
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –≤–æ—Ä–∫–µ—Ä–∞ –¥–ª—è {symbol}: {e}")

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    app.state.repository = repository
    app.state.queue_manager = queue_manager
    app.state.webhook_client = webhook_client
    app.state.workers = workers
    app.state.worker_tasks = worker_tasks

    print(f"üöÄ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º {len(workers)}/{len(instruments)} –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤")
    print(f"üåê –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è: http://0.0.0.0:{settings.port}/docs")

    yield

    # Graceful shutdown
    print("üõë –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–æ—Ä–∫–µ—Ä—ã...")
    for task in worker_tasks:
        task.cancel()

    if worker_tasks:
        try:
            await asyncio.wait_for(
                asyncio.gather(*worker_tasks, return_exceptions=True),
                timeout=5.0
            )
        except asyncio.TimeoutError:
            print("‚ö†Ô∏è –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –≤–æ—Ä–∫–µ—Ä–æ–≤")

    print("‚úÖ –í—Å–µ –≤–æ—Ä–∫–µ—Ä—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")


def create_app() -> FastAPI:
    app = FastAPI(
        lifespan=lifespan,
        title="Webhook Proxy Server",
        version="1.0",
        description="–ü—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –º–µ–∂–¥—É TradingView –∏ Finandy",
        docs_url="/docs",
        redoc_url="/redoc"
    )

    # CORS
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # –†–æ—É—Ç–µ—Ä—ã
    app.include_router(api_router, prefix="/api/v1")

    @app.get("/")
    async def root():
        return {
            "status": "running",
            "service": "webhook-proxy",
            "version": "1.0",
            "docs": "/docs"
        }

    return app


# –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Ç–æ—á–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
app = create_app()

# D:/Stateline/Documents/GitHub/webhook-server\src\services\__init__.py
from services.queue_service import QueueManager  # ‚úÖ –ë–µ–∑ —Ç–æ—á–µ–∫
from services.webhook_service import WebhookClient  # ‚úÖ –ë–µ–∑ —Ç–æ—á–µ–∫
from services.worker_service import SignalWorker  # ‚úÖ –ë–µ–∑ —Ç–æ—á–µ–∫


__all__ = ["QueueManager", "WebhookClient", "SignalWorker"]

# D:/Stateline/Documents/GitHub/webhook-server\src\services\queue_service.py
import asyncio
from typing import Dict, Any
from config.webhooks import get_supported_instruments  # ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–º–ø–æ—Ä—Ç
from core.exceptions import QueueNotFoundException


class QueueManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –æ—á–µ—Ä–µ–¥–µ–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤"""

    def __init__(self):
        self.queues: Dict[str, asyncio.Queue] = {}
        self._init_queues()

    def _init_queues(self) -> None:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—á–µ—Ä–µ–¥–µ–π –¥–ª—è –≤—Å–µ—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤"""
        for symbol in get_supported_instruments():  # ‚úÖ –¢–µ–ø–µ—Ä—å —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞
            self.queues[symbol] = asyncio.Queue()
        print(f"‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {len(self.queues)} –æ—á–µ—Ä–µ–¥–µ–π")

    async def put(self, symbol: str, item: Any) -> None:
        """–î–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤ –æ—á–µ—Ä–µ–¥—å"""
        if symbol not in self.queues:
            raise QueueNotFoundException(f"Queue not found for symbol: {symbol}")

        await self.queues[symbol].put(item)

    async def get(self, symbol: str) -> Any:
        """–ü–æ–ª—É—á–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –æ—á–µ—Ä–µ–¥–∏"""
        if symbol not in self.queues:
            raise QueueNotFoundException(f"Queue not found for symbol: {symbol}")

        return await self.queues[symbol].get()

    def task_done(self, symbol: str) -> None:
        """–ü–æ–º–µ—Ç–∏—Ç—å –∑–∞–¥–∞—á—É –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—É—é"""
        if symbol in self.queues:
            self.queues[symbol].task_done()

    def get_active_queues_count(self) -> int:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ—á–µ—Ä–µ–¥–µ–π"""
        return len(self.queues)

# D:/Stateline/Documents/GitHub/webhook-server\src\services\webhook_service.py
# src/services/webhook_service.py
import aiohttp
import asyncio
from typing import Tuple
from config.settings import settings
from core.exceptions import WebhookSendException


class WebhookClient:
    """–ö–ª–∏–µ–Ω—Ç –¥–ª—è –Ω–∞–¥—ë–∂–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤–µ–±—Ö—É–∫–æ–≤ –≤ Finandy"""

    def __init__(self, timeout: int = None):
        self.timeout = timeout or settings.request_timeout
        self._session = None

    @property
    def session(self) -> aiohttp.ClientSession:
        if self._session is None or self._session.closed:
            self._session = aiohttp.ClientSession()
        return self._session

    async def close(self):
        """–ó–∞–∫—Ä—ã—Ç—å —Å–µ—Å—Å–∏—é –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã"""
        if self._session and not self._session.closed:
            await self._session.close()

    async def send(self, url: str, data: dict) -> Tuple[int, str]:
        """
        –û—Ç–ø—Ä–∞–≤–∏—Ç—å POST-–∑–∞–ø—Ä–æ—Å –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π URL —Å JSON-–¥–∞–Ω–Ω—ã–º–∏.

        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: (status_code, response_text)
        –í—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç: WebhookSendException –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
        """
        try:
            async with self.session.post(
                    url,
                    json=data,
                    timeout=aiohttp.ClientTimeout(total=self.timeout),
                    headers={"Content-Type": "application/json"}
            ) as response:
                response_text = await response.text()
                return response.status, response_text

        except asyncio.TimeoutError:
            raise WebhookSendException(f"Timeout after {self.timeout} seconds")

        except aiohttp.ClientError as e:
            raise WebhookSendException(f"Client error: {str(e)}")

        except Exception as e:
            raise WebhookSendException(f"Unexpected error: {str(e)}")

    async def send_webhook(self, symbol: str, signal_data: dict) -> bool:
        """–£—Ç–∏–ª–∏—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–∏–≥–Ω–∞–ª–∞ –ø–æ —Å–∏–º–≤–æ–ª—É (–¥–ª—è —Ç–µ—Å—Ç–æ–≤ –∏–ª–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)"""
        from config import webhooks

        webhook_url = webhooks.get_webhook_url(symbol)
        if not webhook_url or not webhooks.is_valid_webhook(webhook_url):
            return False

        try:
            status_code, _ = await self.send(webhook_url, signal_data)
            return status_code == 200
        except WebhookSendException:
            return False

# D:/Stateline/Documents/GitHub/webhook-server\src\services\worker_service.py
# src/services/worker_service.py
import asyncio
import time
import os
import traceback
from typing import Dict
from config import webhooks
from database.repository import SignalRepository
from services.webhook_service import WebhookClient


class SignalWorker:
    """–í–æ—Ä–∫–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞"""

    def __init__(
        self,
        symbol: str,
        queue_manager: "QueueManager",
        repository: SignalRepository,
        webhook_client: WebhookClient,
    ):
        self.symbol = symbol
        self.queue_manager = queue_manager
        self.repository = repository
        self.webhook_client = webhook_client
        self.last_sent = 0
        self.rate_limit_ms = int(os.getenv("RATE_LIMIT_MS", "300"))

    async def run(self) -> None:
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –≤–æ—Ä–∫–µ—Ä–∞"""
        print(f"üöÄ –í–æ—Ä–∫–µ—Ä –∑–∞–ø—É—â–µ–Ω –¥–ª—è {self.symbol}")

        while True:
            try:
                print(f"[{self.symbol}] ‚è≥ –û–∂–∏–¥–∞—é –∑–∞–¥–∞—á—É –∏–∑ –æ—á–µ—Ä–µ–¥–∏...")
                item = await self.queue_manager.get(self.symbol)
                print(f"[{self.symbol}] üßµ –ü–æ–ª—É—á–µ–Ω —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –æ—á–µ—Ä–µ–¥–∏")

                if isinstance(item, tuple) and len(item) == 4:
                    data, original_data, name, created_at = item
                    await self._process_signal(data, original_data, name, created_at)
                else:
                    error_msg = f"–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —ç–ª–µ–º–µ–Ω—Ç–∞: {type(item)} (len={len(item) if hasattr(item, '__len__') else '?'})"
                    print(f"[{self.symbol}] ‚ùå {error_msg}")
                    self._log_error("unknown", {}, time.time(), error_msg)

                self.queue_manager.task_done(self.symbol)

            except Exception as e:
                error_msg = f"–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {e}"
                print(f"[{self.symbol}] ‚ùå {error_msg}")
                traceback.print_exc()

                # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –≤—ã–∑–æ–≤ task_done, —á—Ç–æ–±—ã –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –æ—á–µ—Ä–µ–¥—å
                try:
                    self.queue_manager.task_done(self.symbol)
                except ValueError:
                    pass  # —É–∂–µ –ø–æ–º–µ—á–µ–Ω–æ

    async def _process_signal(
        self,
        data: Dict,
        original_data: Dict,
        name: str,
        created_at: float,
    ) -> None:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ –≤ Finandy"""
        try:
            normalized_name = name.strip().upper()
            print(
                f"[{self.symbol}] üîé raw name='{name}' (len={len(name)}), normalized='{normalized_name}'"
            )

            raw_url = webhooks.get_webhook_url(normalized_name)
            webhook_url = raw_url.strip() if raw_url else None

            print(f"[{self.symbol}] üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –Ω–∞ URL: '{webhook_url}'")

            if not webhook_url or not webhooks.is_valid_webhook(webhook_url):
                error_msg = f"–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –≤–µ–±—Ö—É–∫ –¥–ª—è '{normalized_name}': '{raw_url}'"
                self._log_error(normalized_name, original_data, created_at, error_msg)
                return

            await self._rate_limit()

            status_code, response_text = await self.webhook_client.send(
                webhook_url, original_data
            )
            await self._handle_response(
                normalized_name, original_data, created_at, status_code, response_text
            )

        except Exception as e:
            error_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–∏–≥–Ω–∞–ª–∞: {e}"
            print(f"[{self.symbol}] ‚ùå {error_msg}")
            self._log_error(name, original_data, created_at, error_msg)

    async def _rate_limit(self) -> None:
        """–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —á–∞—Å—Ç–æ—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤ (–º–∏–Ω–∏–º—É–º 300 –º—Å –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏)"""
        now = time.time()
        delay = self.rate_limit_ms / 1000.0

        if now - self.last_sent < delay:
            sleep_time = delay - (now - self.last_sent)
            print(f"[{self.symbol}] ‚è∏Ô∏è –°–ø–∏–º {sleep_time:.3f} —Å–µ–∫")
            await asyncio.sleep(sleep_time)

        self.last_sent = time.time()

    async def _handle_response(
        self,
        name: str,
        original_data: Dict,
        created_at: float,
        status_code: int,
        response_text: str,
    ) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –æ—Ç Finandy"""
        sent_at = time.time()

        if status_code == 200:
            status = "sent"
            print(f"[{self.symbol}] ‚úÖ –£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: {status_code}")
        else:
            status = "error"
            print(
                f"[{self.symbol}] ‚ö†Ô∏è –û—à–∏–±–∫–∞: {status_code} ‚Äî {response_text[:200]}"
            )

        self.repository.log_signal(
            symbol=self.symbol,
            name=name,
            data=original_data,
            status=status,
            created_at=created_at,
            sent_at=sent_at,
            response_code=status_code,
            response_text=response_text,
        )

    def _log_error(
        self,
        name: str,
        original_data: Dict,
        created_at: float,
        error_msg: str,
    ) -> None:
        """–ó–∞–ø–∏—Å—å –æ—à–∏–±–∫–∏ –≤ –ë–î –∏ –∫–æ–Ω—Å–æ–ª—å"""
        self.repository.log_signal(
            symbol=self.symbol,
            name=name,
            data=original_data,
            status="error",
            created_at=created_at,
            sent_at=None,
            response_code=None,
            response_text=error_msg,
        )
        print(f"[{self.symbol}] ‚ùå –ó–∞–ø–∏—Å–∞–Ω–∞ –æ—à–∏–±–∫–∞ –≤ –ë–î: {error_msg}")


# D:/Stateline/Documents/GitHub/webhook-server\test_hook.py
import requests
import json

webhook_url = "https://hook.finandy.com/_QAms23yOJcA7fECrlUK"

data = {
    "name": "BOMEUSDTS",
    "secret": "iiulp5at4jn",
    "side": "buy",
    "symbol": "BOMEUSDT",
    "close": {
        "action": "decrease",
        "decrease": {
            "type": "posAmountPct",
            "amount": "1"
        },
        "checkProfit": True,
        "price": ""
    },
    "open": {
        "amountType": "sumUsd",
        "amount": "6",
        "enabled": True
    },
    "dca": {
        "amountType": "sumUsd",
        "amount": "6",
        "checkProfit": False
    },
    "tp": {
        "orders": [
            {"price": "", "piece": "50.0"},
            {"price": "", "piece": "23.0"},
            {"price": "", "piece": "27.0"},
            {"price": "", "piece": "45.0"}
        ],
        "update": False
    },
    "sl": {
        "price": "",
        "update": False
    }
}

response = requests.post(webhook_url, json=data)
print(f"Status Code: {response.status_code}")
print(f"Response: {response.text}")

